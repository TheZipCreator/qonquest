module qonquest.map;

import qonquest.script, qonquest.app, qonquest.action;
import std.file, std.typecons, std.stdio, std.string, std.traits, std.typecons, std.random;
import arsd.terminal;

// handles map loading, drawing, and holds map-related classes

ushort mapWidth;
ushort mapHeight;

struct Province {
  Tuple!(ushort, ushort)[] tiles;
  bool ocean = false;
  string name = "";
  Country* owner;
  ubyte color = 0;
  Tuple!(ushort, ushort) city;
  int[string] vars;
  int troops = 0;
  ushort[] adjacencies;
}
Province[ushort] provinces;
Tuple!(Province*, ushort) findProvince(string name) {
  // find a province by name
  foreach(ushort i, ref Province p; provinces) {
    if(p.name == name) return tuple(&p, i);
  }
  return Tuple!(Province*, ushort)(null, 0);
}
class Country {
  string name;
  ubyte color;
  ushort capital;
  int[string] vars;
  this() {}

  Province[] getAllProvinces() {
    Province[] res;
    foreach(Province p; provinces)
      if(p.owner != null && *(p.owner) == this)
        res ~= p;
    return res;
  }

  ushort[] getAllProvinceIDs() {
    ushort[] res;
    foreach(ushort i, Province p; provinces)
      if(p.owner != null && *(p.owner) == this)
        res ~= i;
    return res;
  }

  int troopsPerTurn() {
    // amt of troops gained per turn
    return cast(int)(getAllProvinces().length*2);
  }

  Tuple!(Province*, Province*)[] frontiers() {
    // all provinces on the border of this country
    // [0] = province from (owned by this country)
    // [1] = province to (owned by other country)
    Tuple!(Province*, Province*)[] res;
    foreach(ref Province p; provinces) {
      foreach(ushort j; p.adjacencies) {
        if(p.owner != null && *(p.owner) == this && provinces[j].owner != null && *(provinces[j].owner) != this) {
          res ~= tuple(&p, &(provinces[j]));
        }
      }
    }
    return res;
  }

  void ai(Terminal* t) {
    t.write("Running AI for ");
    t.color(colors[color], Color.black);
    t.writefln("%s", name);
    t.color(Color.white, Color.black);

    int troopsRemaining = troopsPerTurn();
    auto frontiers = frontiers();
    auto rnd = Random(unpredictableSeed);
    // distribute troops
    while(troopsRemaining > 0 && frontiers.length > 0) {
      int idx = rnd.front%cast(int)(frontiers.length);
      rnd.popFront();
      frontiers[idx][0].troops++;
      troopsRemaining--;
    }
    if(turn > 1) {
      Action[] actions;
      foreach(f; frontiers) {
        if(f[0].troops != 0) { // if we have troops to move
          if(f[0].troops >= f[1].troops) { // if we have more troops than the other country
            actions ~= new MoveAction(f[0], f[1]); // attack
          }
        }
      }
      commitAll(actions, t);
    }
  }

  void update(Terminal* t) {
    ushort[] provs = getAllProvinceIDs();
    auto rnd = Random(unpredictableSeed);
    if(*(provinces[capital].owner) != this && provs.length > 0) {
      // capital has been conquered
      // set new capital to random owned province
      ushort newCap = provs[rnd.front%cast(int)(provs.length)];
      capital = newCap;
    }
  }
}
Country[string] countries;
Country* findCountry(string name) {
  // find a country by name
  foreach(ref Country c; countries) {
    if(c.name == name) return &c;
  }
  return null;
}

void loadMap(string file, Terminal* t) {
  // loads provinces from a map file (generated by mapgen.py)
  Province[ushort] empty;
  provinces = empty; // reset provinces. idk if this is how you're supposed to do it, but it works
  ubyte[] data = cast(ubyte[])std.file.read(file);
  int dataStart = data[0] | (data[1] << 8); // where the map data starts
  mapWidth = data[2] | (data[3] << 8); // width of the map
  mapHeight = data[4] | (data[5] << 8); // height of the map
  for(ushort i = 0; i < mapWidth*mapHeight; i++) {
    ushort x = i%mapWidth;
    ushort y = i/mapWidth;
    ushort id = data[dataStart+i*2] | (data[dataStart+i*2+1] << 8);
    if(id in provinces) {
      // add tile to province
      provinces[id].tiles ~= tuple(x, y);
    } else {
      // create new province and run province setup
      provinces[id] = Province([tuple(x, y)]);
      runScript(format("data/scripts/provinces/%d.qsc", id), new ProvinceScope(&(provinces[id])), t);
    }
  }
}

// for some reason I need 2 different methods for creating a 2d array
// the first acts on primitives (ints, floats, etc)
// the second acts on everything else
T[][] create2dArrayPrim(T)(int width, int height) {
  T[][] arr;
  for(int i = 0; i < width; i++) {
    T[] row;
    for(int j = 0; j < height; j++) {
      row ~= *(new T());
    }
    arr ~= row;
  }
  return arr;
}
T[][] create2dArray(T)(int width, int height) {
  T[][] arr;
  for(int i = 0; i < width; i++) {
    T[] row;
    for(int j = 0; j < height; j++) {
      row ~= new T();
    }
    arr ~= row;
  }
  return arr;
}

ushort[][] constructMap() {
  // returns a 2D array of ushorts, where each element is the ID of the province at that location
  ushort[][] map = create2dArrayPrim!ushort(mapWidth, mapHeight);
  foreach(ushort id, Province p; provinces) {
    foreach(Tuple!(int, int) t; p.tiles) {
      map[t[0]][t[1]] = id;
    }
  }
  return map;
}

enum MapRenderType {
  PROVINCE, COUNTRY
}

class Tile {
  Tuple!(int, int) col;
  dchar c;
  this() {
    c = ' ';
    col = tuple(Color.white, Color.black);
  }
  this(dchar c, Tuple!(int, int) col) {
    this.c = c;
    this.col = col;
  }
}

void renderTiles(Tile[][] tiles, int w, int h, Terminal* t) {
  for(int i = 0; i < h; i++) {
    for(int j = 0; j < w; j++) {
      Tile tile = tiles[j][i];
      t.color(tile.col[0], tile.col[1]);
      t.write(tile.c);
    }
    t.writeln();
  }
  t.color(Color.white, Color.black);
}

void renderMap(MapRenderType mrt, Terminal* t) {
  ushort[][] provs = constructMap();
  Tile[][] tiles = create2dArray!Tile(mapWidth, mapHeight);
  void tileWriteColor(int x, int y, string s, Tuple!(int, int) col) {
    for(int i = 0; i < s.length; i++) {
      tiles[x+i][y].c = s[i];
      tiles[x+i][y].col = col;
    }
  }
  void tileWrite(int x, int y, string s, int fg) {
    for(int i = 0; i < s.length; i++) {
      tiles[x+i][y].c = s[i];
      tiles[x+i][y].col[0] = fg;
    }
  }
  final switch(mrt) {
    case MapRenderType.PROVINCE:
      for(int y = 0; y < mapHeight; y++) {
        for(int x = 0; x < mapWidth; x++) {
          Province p = provinces[provs[x][y]];
          if(p.ocean) {
            tiles[x][y] = new Tile('~', tuple(colors[p.color], cast(int)(Color.black)));
          } else {
            tiles[x][y] = new Tile(' ', tuple(cast(int)(Color.white), colors[p.color]));
          }
          
        }
      }
      foreach(Province p; provinces) {
        if(p.ocean) continue;
        tileWriteColor(p.city[0], p.city[1], "@", tuple(cast(int)(Color.white), colors[p.color]));
        string s = format("%s, %s", p.name, p.owner.name);
        int x = cast(int)(p.city[0]-(s.length/2));
        tileWrite(x, p.city[1]+1, s, cast(int)Color.white);
        s = format("%d", p.troops);
        x = cast(int)(p.city[0]-(s.length/2));
        tileWrite(x, p.city[1], s, cast(int)Color.white);
      }
      break;
    case MapRenderType.COUNTRY:
      for(int y = 0; y < mapHeight; y++) {
        for(int x = 0; x < mapWidth; x++) {
          Province p = provinces[provs[x][y]];
          if(p.ocean) {
            tiles[x][y] = new Tile('~', tuple(colors[p.color], cast(int)(Color.black)));
          } else {
            if(p.owner != null) tiles[x][y] = new Tile(' ', tuple(cast(int)(Color.white), colors[p.owner.color]));     
          }
        }
      }
      foreach(Country c; countries) {
        if(c.getAllProvinces().length > 0) { // make sure country exists
          Province capital = provinces[c.capital];
          int x = cast(int)(capital.city[0]-(c.name.length/2));
          tileWrite(x, capital.city[1], c.name, cast(int)(Color.white));
        }
      }
      break;
  }
  renderTiles(tiles, mapWidth, mapHeight, t);
  t.color(Color.white, Color.black);
}

void registerCountry(string tag, Terminal* t) {
  countries[tag] = new Country();
  runScript(format("data/scripts/countries/%s.qsc", tag), new CountryScope(&(countries[tag])), t);
}